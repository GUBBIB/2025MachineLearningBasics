# Conv2D

## 하는 일
- 2D 합성곱 레이어를 만든다.
- 이미지에서 ``특징(feature)`` 을 추출하는 역할을 하며 ``필터(커널)`` 을 이용해 이미지에서 ``중요한 패턴``을 감지한다.<br>
    - 필터를 거쳐서 나온 값이 클수록 특징이 뚜렷하다는 의미이다.

  **※ Conv2D가 특징을 추출하는 방법<br>**
    ``가중치`` 가 들어있는 ``필터(커널)``이 이미지의 **일부 영역**과 ``합성곱 연산`` 을 해서 값을 도출해낸다.
    ``필터(커널)``의 ``가중치``에 따라서 추출하는 **특징** 이 다양하게 나오고 그 ``필터(커널)``의 값은 레이어가 학습을 하면서 **자동** 으로 결정한다.

## 형식
```python
tf.keras.layers.Conv2D(
    filters,               # 출력 채널 수 (= 필터 수)
    kernel_size,           # 필터 크기
    strides=(1, 1),        # 필터 이동 간격
    padding='valid',       # 가장자리 처리 방법
    activation=None,       # 활성화 함수
    use_bias=True,         # 바이어스를 쓸지 말지
    kernel_initializer='glorot_uniform',  # 필터 초기값
    bias_initializer='zeros',             # 바이어스 초기값
    input_shape=None       # 첫 레이어일 때 입력 크기
)
```
*****
- ``filters``: 필터(커널)의 개수이며, 보통 ``32``, ``64``, ``128`` 처럼 필터의 수를 점점 늘린다.
    - 필터의 개수가 2의 배수만큼 늘어나면 연산량도 2배 늘어난다.
    - 2의 승수가 아닌 ``10``, ``20``, ``40`` 을 값으로 줄 수도 있다.
    
    ※ 보통은 filters의 개수가 많을수록 여러가지 필터가 있기 때문에 **다양한 특징**을 추출하지만, **무조건적** 으로 그런것은 아니다.
*****

- ``kernel_size`` : **정방향(3)** 또는 **튜플(3, 3)** 등 ``합성곱``을 할 **필터(커널)** 의 크기를 정한다.
*****

- ``strides=(1, 1)`` : **필터(커널)**가 움직이는 ``보폭``을 정한다.
    - **필터(커널)** 의 크기가 클수록 **출력 크기가 작아지고** **계산량도 줄어**든다. 하지만 ``MaxPooling2D 연산`` 으로 크기를 줄이기 때문에 보통 기본값인 ``(1, 1)`` 을  사용한다.
*****

- ``padding='valid'`` : 가장자리를 어떻게 처리할지 정한다.
    - ``vaild``: 기본연산이며 가장자리 바깥까지 필터(커널)가 도달하지 못한다.
        - 가장자리 바깥까지 도달하지 못하기 때문에 ``[입력 크기: A, 필터 크기 : n]`` 일 때, 출력 크기가 ``A - (n - 1)`` 로 나온다.
    - ``same`` : 가장자리에 ``0``을 추가해서 **필터(커널)** 가 연산을 가장자리까지 할 수 있게 해준다.<br>
    
    ※ ``valid`` 는 바깥까지 도달하지 못하기 때문에 이미지의 가장자리 특징을 제대로 **추출하지 못하지만** , ``same`` 은 이미지의 **가장자리 특징**까지 **추출할 수 있다**.
*****

- ``activation=None`` : ``활성화 함수``라고 부르며 **필터(커널)** 가 계산해서 만든 값들 중에서 어느 걸 **살릴지** / **버릴지** 를 결정하는 함수 이다.
    - ``ReLU(Rectified Linear Unit)`` : **0보다 작은 값은 모두** ``0``으로 만들고 **0보다 큰 값은 그대로 놔두는** 함수이다. (``x < 0: 0`` , ``x >= 0: x``)
        - 가장 많이 사용되는 함수이다.
        - 중요한 특징만 강조하고, 덜 중요한 특징은 무시하는 함수이다.<br>
        **ex)** ``[-2, 0, 3] → [0, 0, 3]``

    - ``sigmoid`` : 모든 값을 ``0``과 ``1`` 사이로 **압축** 하는 함수이다.
        - 출력이 확률처럼 보이기 때문에, **이진 분류(yes/no)** 문제에서 자주 사용한다. <br>
        **ex)** `[-2, 0, 2] → [0.12, 0.5, 0.88]`

    - ``tanh`` : 값을 ``-1``과 ``1``사이로 변환한다.
        - ``sigmoid`` 와 비슷하지만 중심이 0이라서 데이터가 **양수/음수**로 나뉘는 경우 더 자연스럽게 작동한다.  
        - 주로 **RNN(순환 신경망)** 등에서 사용된다.  <br>
        **ex)** ``[-2, 0, 2] → [-0.96, 0, 0.96]`` 

    - ``softmax`` : **가장 높은 값을 강조**하고, 전체를 **확률처럼 정규화**한다.  
        - 출력값들의 총합이 1이 되도록 바꿔서, **다중 분류 문제(고양이/강아지/토끼 등)** 에서 사용한다. <br>
        **ex)** ``[2.0, 1.0, 0.1] → [0.65, 0.24, 0.11]``

    ※ 만약 **활성화 함수** 를 ``none`` 으로 준다면 그저 복잡한 문제는 해결 못하고 **곱셉** + **덧셈** 만 반복하는 ``선형 함수`` 밖에 안 된다. **활성화 함수** 를 선택 해줌으로써 복잡한 문제를 해결 할 수 있는 ``비선형 함수`` 가 된다.
*****

- ``use_bias=True`` : ``바이어스``를 사용할지 말지 정하며, 값을 한쪽으로 밀어주는 역할을 한다.<br>
    - **True** : ``바이어스 사용`` <br>
        - 각 필터에 **대응하는 바이어스 값이 존재** 하며 합성곱 연산 결과에 **바이어스를 더해서** 출력값을 조정하단다.
    바이어스를 사용한다면 모델의 표현력이 올라가고, 더욱 유연한 학습이 가능하다.<br>
    
        ※ 바이어스 값은 필터와 마찬가지로 학습 과정에서 ``자동``으로 **조정**되며, **최적의 값**을 찾는다.

    - **False** : ``바이어스 미사용`` <br>
        - 합성곱 연산 결과에 추가적인 조정 없이 그대로 출력한다.
        - 계산이 단순해지며, 표현력이 약해진다.

    - 바이어스 예시 사진
        - ``빨간 실선 = 바이어스가 3인 경우``, ``파란색 점선 = 바이어스가 없는 경우``
    
    <img src="https://github.com/user-attachments/assets/46fa0f31-8a1c-4a1e-9217-6e24b35a8c4e" width="500px" height="500px">


    ※ 위의 그래프처럼 출력값을 각 필터마다 ``위/아래`` 로 밀어줌으로써 **단순한 선형 패턴** 에서 **비선형적인 패턴** 으로 학습을 할 수 있게 해준다.<br>
    
*****
- ``kernel_initializer='glorot_uniform'`` : **필터(커널)** 의 ``가중치``의 **초기값**을 정한다.
    - ``glorot_uniform``이 기본값으로 **Xavier 초기화** 라고부르며, **균등분포** 기반으로 적적히 분산된 값으로 초기화한다.
    
    ※ 이외에 ``정규분포 기반``, ``균등분포 기반`` 등 여러가지가 있지만 특수한 상황이 아닌경우는 전부 다 ``glorot_uniform``을 사용한다.

*****
- ``bias_initializer='zeros'`` : 바이어스의 초기값을 정한다.
    - ``zeros``는 모든 바이어스의 초기값을 0으로 초기화시킨다.
    
    ※ ``zeros`` 말고도 ``ones``, ``random_normal`` 등 여러가지가 있지만 실험적 설정 또는 특수한 상황이 아닌경우는 전부 다 ``zeros``를 사용한다.

*****
- ``input_shape=None`` : ``input_shape=(Height, Weight, Channels)`` 형태로 입력 이미지의 크기와 이미지 채널 개수를 등록한다. <br>
    - 첫번째 레이어에서만 사용을 한다.

    ※ 하지만 Conv2D 레이어에서 같이 shape을 지정하는 것 보다 ``layer.Import`` 객체를 사용하는 것이 **권장**된다.
*****